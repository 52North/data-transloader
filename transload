#!/usr/bin/env ruby -Ilib
require 'transloader'
require 'pry'

# Adjust the logging level based on the "LOG_LEVEL" environment 
# variable.
LOG_LEVELS = {
  "ERROR" => :error,
  "WARN"  => :warn,
  "INFO"  => :info,
  "DEBUG" => :debug,
  "TRACE" => :trace
}
env_log_level = ENV["LOG_LEVEL"].nil? ? nil : ENV["LOG_LEVEL"].upcase
level = LOG_LEVELS.fetch(env_log_level, :info)

SemanticLogger.default_level = level
SemanticLogger.add_appender(io: $stdout)
SemanticLogger.add_appender(io: $stderr, level: :error)

$logger = SemanticLogger['Transload']

def get_station(options, http_client)
  $logger.debug "Creating station instance for #{options.provider}"
  case options.provider
  when "environment_canada"
    Transloader::Station.new({
      cache:       options.cache,
      http_client: http_client,
      provider:    "environment_canada",
      station_id:  options.station_id
    })
  when "data_garrison"
    Transloader::Station.new({
      cache:       options.cache,
      http_client: http_client,
      provider:    "data_garrison",
      station_id:  options.station_id,
      user_id:     options.user_id
    })
  when "campbell_scientific"
    Transloader::Station.new({
      cache:       options.cache,
      data_urls:   options.data_urls,
      http_client: http_client,
      provider:    "campbell_scientific",
      station_id:  options.station_id
    })
  end
end

def get_metadata(options, http_client)
  $logger.debug "Getting metadata"
  station = get_station(options, http_client)
  station.download_metadata(overwrite: options.overwrite)
end

def put_metadata(options, http_client)
  $logger.debug "Putting metadata"
  station = get_station(options, http_client)
  station.upload_metadata(options.destination,
    allowed: options.allowed,
    blocked: options.blocked)
end

def get_observations(options, http_client)
  $logger.debug "Getting observations"
  station = get_station(options, http_client)
  station.download_observations(options.date)
end

def put_observations(options, http_client)
  $logger.debug "Putting observations"
  station = get_station(options, http_client)
  station.upload_observations(options.destination, options.date,
    allowed: options.allowed,
    blocked: options.blocked)
end

# Parse Args
parser  = Transloader::CommandLineOptionParser.new
args    = parser.parse(ARGV)
verb    = args[0]
noun    = args[1]
options = args[2]
# Create re-usable HTTP client with pre-set options
http_client = Transloader::HTTP.new(
  auth:    options.http_auth,
  headers: options.http_headers
)

# Determine action
if verb == :get && noun == :metadata
  get_metadata(options, http_client)
elsif verb == :put && noun == :metadata
  put_metadata(options, http_client)
elsif verb == :get && noun == :observations
  get_observations(options, http_client)
elsif verb == :put && noun == :observations
  put_observations(options, http_client)
end
